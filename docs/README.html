<!DOCTYPE html>
<html>
<head>
<title>README</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
<h2>Problem statement</h2>
<p>We try to solve a stochastic dynamic programming problem
in inventory control, with the following DP equation:
$$
V _i (x)= \max _{z,q} [\mathbf {E} ~ \textrm {cost} 
(x,z,q,D) + \alpha \mathbf {E} ~ V _{i+1} (\textrm {dynamic} (x,z,q,D))]
$$</p>
<p>where \(x \in S= [0, k-1] ^m\), that is, each state
is a m-dimension vector \(x= (x _1, ..., x _m) \), 
with each element in the range \([0,k-1]\).
An action is a two-dimension vector \( (z,q)\).
\(z\) stands for depletion quantity, \(q\) order quantity.
\(V _i (x)\) is called the value of state \(x\)
in period \(i\).</p>
<p>Here is the story: The firm holds inventory with different
expiry dates, for instance \(x=(2,4,3)\) means there is 
2 units of inventory that will expire in one period, 4 units
that will expire in two periods, and 3 units that will expire
in three periods. The manager standing at the beginning of the period faces two decisions: how much to deplete (z)
 and how much to order (q). The depletion is to reduce the holding cost as well as reduce potential expiry items,
and the order is to fulfill forthcoming demands. The timeline is as follows: At the beginning of each period,
the manager decides the depletion quantity z and order quantity q, then demand realizes, and remaining inventory
carried over to the next period (those unsold inventory with one period to expire go outdated). For example,
if \( (z,q)=(2,3), D=4\), then 
\( x=(4,1,2)\rightarrow (2,1,2) (\textrm{depleted by 2 units}) \rightarrow (2,1,2,3)  (\textrm{3 units of order added })
\rightarrow (0,0,1,3) (\textrm{demand realized}) \rightarrow  (0,1,3) = \textrm{dynamic} (x, z,q, D).\)</p>
<p>The boundary condition \(V _{T} (\cdot)\) is given, so 
we can compute \(V _0 (\cdot)\) in a bottom-up way:
first compute \(V _{T-1} (\cdot)\) based on \(V _{T} (\cdot)\)
and the DP equation, then \(V _{T-2} (\cdot)\) based on \(V _{T-1} (\cdot)\),etc.</p>
<p>A policy \(f\) specifies the action in each period
based on the current state, and we have the following 
equation
$$
V _{f,i} (x)= \mathbf {E} ~ \textrm {cost} 
(x,z _f,q _f,D) + \alpha \mathbf {E} ~ V _{f, i+1} (\textrm {dynamic} (x,z _f,q _f,D))
$$</p>
<p>where \( (z _f, q _f) \) is the action taken under
policy \(f\), when the state is \(x\) and period 
\(i\).</p>
<p>Our objective is to compute \(V _0 (x)\) and 
\( V _{f,0} (x)\) for some specified policy \(f\), and 
expect that the relative difference is small when some
model parameters scaled up. </p>
<h2>Algorithm description</h2>
<p>We have two parts: first compute \(V _0 (x)\) then
\( V _{f,0} (x)\).</p>
<p>In the first part, we use an array <strong>Valuevec</strong> to store
the value of each state in \(S= [0, k-1] ^m\), so
the length of <strong>Valuevec</strong> is \(k ^m\). </p>
<p>Initially
set <strong>Valuevec</strong> \( =V _T (\cdot)\).  Then at each iteration we compute \(V _{i-1} (\cdot)\) from \(V _{i} (\cdot)\), which is stored in <strong>Valuevec</strong>,  and update <strong>Valuevec</strong> with \(V _{i-1} (\cdot)\). After \(T\) iterations, we obtain \(V _0 (\cdot)\) stored in <strong>Valuevec</strong>.</p>
<p>The second part is a straightforward recursive computation, thus omitted.</p>
<h3>list of notations and variables</h3>
<ul>
<li><strong>m</strong> dimension of state space</li>
<li><strong>k</strong> max number on each dimension of state</li>
<li><strong>T</strong> number of periods</li>
<li><strong>n_sample</strong> sample size used to approximate expectation</li>
<li><strong>drate,h,r,c,theta,s,alpha,maxhold</strong> other model parameters</li>
<li><strong>Valuevec</strong>
  an array storing the value of all states.</li>
<li><strong>temp</strong>
  an intermediate array storing the result at each iteration, then passed on to <strong>Valuevec</strong>.</li>
<li><strong>ind</strong>
  state indicator array, &quot;true&quot; stands for already
  calculated, &quot;false&quot; not calculated.</li>
<li><strong>Demands</strong>
  sample paths generated by <strong>genDemand()</strong></li>
<li><strong>genDemand</strong> generate sample paths of each period</li>
<li><strong>code, decode</strong> link each state (a high-dim array) to
its subscript in <strong>Valuevec</strong>.
for example, when \(k=10, m=3\), then each state 
\( (a,b,c)\) is stored in <strong>Valuevec</strong> with subscript
 \(100a+10b+c\). So code\( (2,3,4)= 234\), decode
\( (436)= (4,3,6). \)</li>
<li><strong>cost<em>to</em>go</strong> cost function in the DP equation</li>
<li><strong>dep</strong>  the remaining profile of state \(x\) 
after depleting \(z\) units </li>
<li><strong>dep_one</strong> the remaining profile after depleting one unit</li>
<li><strong>dynamic</strong> the evolution dynamic of state from current
period to next period</li>
<li><strong>obj</strong>  the objective value function appearing in 
the DP equation, which we try to maximize on.</li>
<li><strong>optq</strong> the optimal order quantity of state \(x\),
  after depletion is committed.</li>
<li><strong>wrapobj</strong> the wrapped version of <strong>obj</strong>, only containing decision variable \(z\).</li>
<li><strong>optz</strong> the optimal depletion quantity \(z\) that maximizes
<strong>wrapobj</strong></li>
<li><strong>fillvalue!</strong>  the procedure of filling <strong>temp</strong> </li>
<li><strong>premainprog!</strong> calculate some state values on the local machine.</li>
<li><strong>mainprog!</strong> calculate values of those states distributed to machine with label <strong>jobno</strong>.</li>
</ul>
<h3>State space cut and optimization</h3>
<p>Our algorithm has \(T\) big iterations, which is processed sequentially, thus cannot be paralleled in this level. In each iteration, however, we have to compute the value
of each  state using the DP equation,  equivalent to solving \(k ^m\) subproblems, which can be paralleled.</p>
<p>Also, we can use the tree structure of state space to reduce computation. <strong>dep_one</strong> shows how the tree is formed. For each state x, we can deplete one by one until it's empty, thus forming a path, for example:
\( (1,3,1)\rightarrow (0,3,1) \rightarrow (0,2,1) \rightarrow (0,1,1) \rightarrow (0,0,1) \rightarrow (0,0,0).\)
Each state regarded as a node, will eventually go to the root node
\( (0,...,0)\). Thus we formed a tree for our state space.</p>
<p>Our observation is that if one node is computed, then all its son nodes (the path to the root node) needs not be computed. For example, if the optimal action for \(
(2,3,5)\) is \((z ^{\ast}, q ^{\ast})= (3,4) \), then
we know the optimal action for \((1,3,5)\) is 
\( (2,4)\), the optimal action for \((0,3,5)\) is
\( (1,4)\), etc. </p>
<p>Thus we can just compute 
all leaf nodes to obtain the value of all nodes. 
Also, different nodes have common son nodes, which should be utilized to optimize the algorithm.</p>
<h3>New idea! Algorithm redesign: Threshold policy</h3>
<p>It has been proved in the literature the optimal 
policy is kind of threshold policy. So instead of seeking
for an optimal policy for every state, We only need to find the thresholds for each level and store it. For any 
state, we compare its element on each level and the corresponding threshold, and determine the optimal 
depletion policy. (order policy will be mentioned later)</p>
<p>To be concrete, in period \(t\), for each level 
\(1 \le i \le m\) there is a threshold \(\bar {z}
_{t,i} = \bar {z} _{t,i} (x _{i+1}, ..., x _m)\)
(means it depends only on newer inventory), such that
for a state \(x=(x _1,..., x _m)\), on level
\(i\) if \(x _i &gt; \bar {z} _{t,i} \) , then deplete
down to \(\bar {z} _{t,i} \), otherwise do nothing.</p>
<p>Assume we have computed all the thresholds
\(\bar {z} _m, \bar {z} _{m-1} (x _m),..., \bar {z}
_1 (x _1,..., x _m) \). To find the optimal policy
for \(y= (y _1,..., y _m)\), we should start with the newest items and progress to the oldest ones. As long as \( y _i &gt; \bar {z} _i\) for some \(i\), then
deplete \(y _i\) down to \(\bar {z} _i\), and 
deplete all older items (level \(\le i\)).
(This should be intuitive because newer inventory 
has more value, you always deplete from the oldest inventory).</p>
<p>The number of thresholds is \( 1+k+...+k ^{m-1}\),
which is much smaller than \(k ^m\), the number of states. Also, we can make use of the monotonicity of 
threshold function to reduce computation.</p>
<h4>A sketch of threshold algorithm</h4>
<ul>
<li>for t=1:T, do the following steps. (Essentially filling
a \(k ^m\)-element table each step)</li>
<li>for i=m:1, for \(y _m \le z _m ^{\ast},y _{m-1}
\le z _{m-1} ^{\ast} (y _m),...,y _{i+1}
\le z _{i+1} ^{\ast} (y _{i+2},...,y _m)\),</li>
</ul>
<p>compute \(z _i ^{\ast} (y _{i+1},...,y _m),~ q _i ^{\ast}
(z _i ^{\ast}, y _{i+1},..., y _m)\).</p>
<p>It should be noted that to compute each threshold value,
the monotonicity property that \(z _i ^{\ast} (y _{i+1},...,y _m)\) is decreasing function of each variable
could be used. How to efficiently take this advantage is
to be discussed. </p>
<ul>
<li>for \(x=(x _1,...,x _m)\), use the computed threshold values to find \(z ^{\ast} (x),~ q ^{\ast}(x).\) Update \(V(x)\).</li>
</ul>
<h3>Second Algorithm: Top-down Algorithm</h3>
<p>$$
V _t (x)= \max _{z,q} v _t (x,z,q) =
\max _{z,q} [\mathbf {E} ~ \textrm {profit} 
(x,z,q,D) + \alpha \mathbf {E} ~ V _{t+1} (\textrm {dynamic} (x,z,q,D))]
$$</p>
<p>First we define an auxiliary function \( u _t (x,z)= \max _q u _t (x,z,q)\) (use linear search over \([0,k-1]\)).</p>
<ol>
<li>Initialization: \( V _{T+1}(x) = s \cdot \textrm{sum} (x)\);</li>
<li>for \(t= T:0\) do the following steps.</li>
<li>for \(n=1:(m-1)\), start with \(k ^{n}\) elements as basic row, and perform \(k-1\)
 iterations using GPU;</li>
<li>Each iteration compute \(k ^n\) elements in parallel, specified in step 5;</li>
<li>Compute each of the \(k ^n\) elements (denoted as \(x\)): let \(y\) be the father of 
\(x\)(already computed), two cases: 
if \(z ^{\ast} (y)=0\), then \(z ^{\ast} (x) =0 ~\textrm{or}~ 1\); else if 
\(z ^{\ast} (y)&gt; 0\),  then \(z ^{\ast} (x) =z ^{\ast} (y) +1, ~ q ^{\ast} (x) =q ^{\ast} (y).\)</li>
</ol>
<p>It's easily seen that we save a lot of work in step 5 by making use of the father-son link.
About the state division, see Cube.pdf by Bairen, which is very intuitive.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
